import numpy  as np
import scipy
import math
from scipy import linalg
from matplotlib import pyplot as plt
import random
from scipy.integrate import odeint
from scipy.integrate import quad

def H(s,a,b):

    return np.array([[s*b*b,-s*a*b],[-s*a*b,1 - s*b*b]])

def func(z,list_of_s):
    x1 = z[0]
    x2 = z[1]
    y1 = z[2]
    y2 = z[3]
    s = z[4]

    T = 1000
    a = 0.1
    b = math.sqrt(1 - a*a)
    B = s*b*b
    A = s*a*b
    dx1ds = T*(B*x2 - A*y2)
    dx2ds = T*(-B*x1 + A*y1)
    dy1ds = T*(-A*x2 + (1-B)*y2)
    dy2ds = T*(A*x1 - (1-B)*y1)
    dsds = 1
    return np.array([dx1ds,dx2ds,dy1ds,dy2ds,dsds])

def g(x,a,b):

    return math.sqrt(a*a + b*b*(1-2*x)**2)


def integrate_g(s,a,b):

    I = quad(g, 0, s, args=(a,b))

    return I[0]

def eps_integrand_real(s,a,b,T):

    G = quad(g,0,s,args = (a,b))[0]

    return math.cos(T*G)/g(s,a,b)**2

def eps_integrand_imag(s,a,b,T):

    G = quad(g,0,s,args = (a,b))[0]

    return math.sin(T*G)/g(s,a,b)**2

def eps(s,a,b,T):

    I1 = quad(eps_integrand_real,0,s,args = (a,b,T))[0]
    I2 = quad(eps_integrand_imag,0,s,args = (a,b,T))[0]

    return I1 + 1j*I2


# Number of site is 2, dimension is 4
site = 1
dim = 2

# Set the number of total steps to be L = 100
L = 5000
# Set total simulation time to be T = 20
T = 1000
a = 0.1
b = math.sqrt(1 - a*a)
dt = T/L

# Construction of the states in Grover's search

# Set the init_state as the ground state of H1
init_state = np.zeros((dim),dtype = complex)
eigX,vecX = np.linalg.eig(H(0,a,b))
gs_x = np.argsort(eigX)[0]
for ix in range(dim):
    init_state[ix] = vecX[ix][gs_x]

H_deriv = np.array([[b*b,-a*b],[-a*b,-b*b]])

time_step = np.zeros(L)
fid_err = np.zeros(L)
energy_gap = np.zeros(L)
analytic_err = np.zeros(L)
agp = np.zeros(L)

# Ode
list_of_s = np.linspace(0,1,L)
z0 = np.array([1,0,0,0,0])
z = odeint(func,z0,list_of_s)
x1 = z[:,0]
x2 = z[:,1]
y1 = z[:,2]
y2 = z[:,3]




# Discrete_adb is the state evolved under discrete adiabatic evolution,
# and the initial state is the ground state of H1
Discrete_adb = np.zeros(dim,dtype = complex)
for i in range(dim):
    Discrete_adb[i] = init_state[i]

for count in range(L):
    s = (count+1)/L

    Ode_temp = np.array([x1[count] + 1j*x2[count], y1[count] + 1j*y2[count]])

    # H_temp represents the adiabatic path H(s)
    H_temp = H(s,a,b)
    U_temp = scipy.linalg.expm(-1j*H_temp*dt)

    # Discrete_adb is generated by product of adiabatic walk operator
    Discrete_adb = U_temp.dot(Discrete_adb)

    # Ideal_adb is the ground state of H(s)
    gs_temp = np.zeros(dim,dtype = complex)
    fst_temp = np.zeros(dim,dtype = complex)
    eig,vec = np.linalg.eig(H_temp)
    gs = np.argsort(eig)[0]
    fst = np.argsort(eig)[1]
    for i in range(dim):
        gs_temp[i] = vec[i][gs]
        fst_temp[i] = vec[i][fst]

    # fid_err is the fidelity error (1 - |<v1|v2>|**2)**(1/2)
    # energy_gap is the spectral gap of H(s)
    time_step[count] = s
    # fid_err[count] = math.sqrt(1 - abs(np.vdot(Discrete_adb,gs_temp))**2)
    fid_err[count] = abs(np.vdot(Discrete_adb,fst_temp))
    energy_gap[count] = eig[fst].real - eig[gs].real
    analytic_err[count] = 1 - abs(np.vdot(Discrete_adb,Ode_temp))**2
    agp[count] = abs(np.vdot(gs_temp,H_deriv.dot(fst_temp)))


# Linear expansion
L2 = 100
X = np.linspace(0,1,L2)
Y = np.zeros(L2)
for j in range(L2):
    Y[j] = a*b*abs(eps(X[j],a,b,T))

plt.scatter(time_step,fid_err,label = 'fidelity error')
# plt.scatter(time_step,energy_gap,label = 'energy gap')
# plt.scatter(time_step,agp,label = 'adiabatic gauge potential')
# plt.plot(time_step,analytic_err,label = 'analytic error')
plt.plot(X,Y,c = 'y',label = 'linear expansion')
plt.legend()
plt.show()


