import numpy  as np
import scipy
import math
from scipy import linalg
from matplotlib import pyplot as plt
import random

# Number of site is 2, dimension is 4
site = 2
dim = 2**site

# Parameter alpha and beta
a = -2
b = 0.5
# Set the number of total steps to be L = 100
L = 1000
# Set total simulation time to be T = 20
T = 20
dt = T/L

# Construction of Pauli operators
X = np.array([[0,1],[1,0]])
Z = np.array([[1,0],[0,-1]])
I = np.array([[1,0],[0,1]])
X1 = np.kron(X,I)
X2 = np.kron(I,X)
XX = np.kron(X,X)
Z1 = np.kron(Z,I)
Z2 = np.kron(I,Z)
ZZ = np.kron(Z,Z)

# Construction of the three parts in Hamiltonian 
H1 = (-1)*(X1 + (1-b)*X2) 
H2 = a*XX 
H3 = (ZZ - Z1 - Z2)

# Set the init_state as the ground state of H1
init_state = np.zeros((dim),dtype = complex)
eigX,vecX = np.linalg.eig(H1)
gs_x = np.argsort(eigX)[0]
for ix in range(dim):
    init_state[ix] = vecX[ix][gs_x]

time_step = np.zeros(L)
fid_err = np.zeros(L)
energy_gap = np.zeros(L)

# Discrete_adb is the state evolved under discrete adiabatic evolution,
# and the initial state is the ground state of H1
Discrete_adb = np.zeros(dim,dtype = complex)
for i in range(dim):
    Discrete_adb[i] = init_state[i]

for count in range(L):
    s = (count+1)/L

    # H_temp represents the adiabatic path H(s)
    H_temp = (1-s)*H1 + s*(1-s)*H2 + s*H3
    U_temp = scipy.linalg.expm(-1j*H_temp*dt)

    # Discrete_adb is generated by product of adiabatic walk operator
    Discrete_adb = U_temp.dot(Discrete_adb)

    # Ideal_adb is the ground state of H(s)
    Ideal_adb = np.zeros(dim,dtype = complex)
    eig,vec = np.linalg.eig(H_temp)
    gs = np.argsort(eig)[0]
    fst = np.argsort(eig)[1]
    for i in range(dim):
        Ideal_adb[i] = vec[i][gs]

    # fid_err is the fidelity error (1 - |<v1|v2>|**2)**(1/2)
    # energy_gap is the spectral gap of H(s)
    time_step[count] = s
    fid_err[count] = math.sqrt(1 - abs(np.vdot(Discrete_adb,Ideal_adb))**2)
    energy_gap[count] = eig[fst] - eig[gs]

plt.scatter(time_step,fid_err,label = 'fidelity error')
plt.scatter(time_step,energy_gap,label = 'energy gap')
plt.legend()
plt.show()


