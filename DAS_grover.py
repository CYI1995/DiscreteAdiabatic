import numpy  as np
import scipy
import math
from scipy import linalg
from matplotlib import pyplot as plt
import random

def proj(vec,dim):
    P = np.zeros((dim,dim),dtype = complex)
    for i in range(dim):
        vi = vec[i]
        for j in range(dim):
            P[i][j] = np.conj(vi)*vec[j]

    return P

# Number of site is 2, dimension is 4
site = 6
dim = 2**site

# Set the number of total steps to be L = 100
L = 100
# Set total simulation time to be T = 20
T = 500
dt = T/L

# Construction of the states in Grover's search
v1 = np.zeros(dim)
v2 = np.zeros(dim)
v1[0] = 1
for l in range(dim):
    v2[l] = 1/math.sqrt(dim)
H1 = np.identity(dim,dtype = complex) - proj(v1,dim)
H2 = np.identity(dim,dtype = complex) - proj(v2,dim)

# Set the init_state as the ground state of H1
init_state = np.zeros((dim),dtype = complex)
eigX,vecX = np.linalg.eig(H1)
gs_x = np.argsort(eigX)[0]
for ix in range(dim):
    init_state[ix] = vecX[ix][gs_x]

time_step = np.zeros(L)
fid_err = np.zeros(L)
energy_gap = np.zeros(L)

# Discrete_adb is the state evolved under discrete adiabatic evolution,
# and the initial state is the ground state of H1
Discrete_adb = np.zeros(dim,dtype = complex)
for i in range(dim):
    Discrete_adb[i] = init_state[i]

for count in range(L):
    s = (count+1)/L

    # H_temp represents the adiabatic path H(s)
    H_temp = (1-s)*H1 + s*H2
    U_temp = scipy.linalg.expm(-1j*H_temp*dt)

    # Discrete_adb is generated by product of adiabatic walk operator
    Discrete_adb = U_temp.dot(Discrete_adb)

    # Ideal_adb is the ground state of H(s)
    Ideal_adb = np.zeros(dim,dtype = complex)
    eig,vec = np.linalg.eig(H_temp)
    gs = np.argsort(eig)[0]
    fst = np.argsort(eig)[1]
    for i in range(dim):
        Ideal_adb[i] = vec[i][gs]

    # fid_err is the fidelity error (1 - |<v1|v2>|**2)**(1/2)
    # energy_gap is the spectral gap of H(s)
    time_step[count] = s
    fid_err[count] = math.sqrt(1 - abs(np.vdot(Discrete_adb,Ideal_adb))**2)
    energy_gap[count] = eig[fst].real - eig[gs].real

plt.scatter(time_step,fid_err,label = 'fidelity error')
plt.scatter(time_step,energy_gap,label = 'energy gap')
plt.legend()
plt.show()


